# Docker

Розроблений додаток доставляться з використанням [Docker](https://www.docker.com/) REST-API технологі: Дані, які необхідно промарувати подаються у вигляді запиту до АРІ, яке повертає результат маркування в залежності від задачі. Всього імплементовано три контейнера для таких задач:
- Розпізнавання емоційного забарвлення - *модуль DET_EMOTION_MODEL*
- Розпізнавання потенційного контексту повідомлення - *модуль DET_TOPICS_MODEL*
- Оцінка ступені "специфічності" повідомлення від 0 до 1 - *модуль DET_APPROP_MODEL*

## Перший запуск

Для запуску застосунків для початку необхідно виконати в консолі срипт-білдер для створення Docker image для master(приймає АРІ запити) та workers(обробляють повідомлення). Оскільки при першому запуску будуть завантажені усі використовувані моделі, а також бібліотеки для середовища, то виконання файлу може становити близько 10-15 хвилин.

```
build_container.bat
```

Даний скрипт використовує процесор як обчислювальну одиницю та оперативну пам'ять для зберігання моделей, однак ці налаштування можна змінювати. В якості демонстраційного прикладу було відключено дві моделі з метою зменшення навантаження на систему. 

## Використання

Після того як скрипт відпрацює буде запущено два docker image, один для основного(master) та другий для обробника(worker). Усі запити надсилаються на master контейнер. За замовчуванням стандартна адреса доступу - 127.0.0.1:8228 Тому для перевірки правильності встановення можна перейти за адресою [http://localhost:8228/](http://localhost:8228/) і подививтись на результат, який прийде: при успішному запуску повертається "Hello World" повідомлення. Для використання предіктору за назначенням, необхідно використовувати обробник http://localhost:8228/label

Формат запиту до серверу має наступний формат JSON:
```
{
    "message": ["msg1", "msg2", ...],
    "source_lang": None,
    "env": DET_EMOTION_MODEL
}
```

Параметр message являє собою список повідомлень у текстовому форматі, які необхідно класифікувати; source_lang - мова джерела, за замовчуванням null, оскільки практичної доцільності набагне в майбутньому; env - змінна, яка відповідає за назву обробника повідомлень, встановлюється відповідно до трьох значень, наведених вище.

Результатом такого POST запиту, не залежно від задачі та мови, буде результат в наступному форматі:

```
{
    "text": message,
    "source_lang": source_lang,
    "env": env,
    "label": ["POSITIVE", "NEGATIVE", ...],
    "logits": [[0.01, 0.9, 0.3]],
    "calculation_time": 0.4213123
}
```

Відповідно тут додаються такі нові дані: labels - мітки емоцій в порядку відповідному вхідних повідмоленням; logits - масив масивів чисел з плаваючою точкою, які характеризують впевненність мережі у відповіді; calculation_time - час, затрачений на обробку вхідних повідомлень воркером.

Приклади запитів для розпізнавання емоційного забарвлення наведено нижче:

```
from numpy.lib.utils import source
import requests
import pprint
from requests.utils import quote

url = 'http://localhost:8228'
#####################################
# Повідомлення
messages = [
    'Я люблю дарить улыбку, ', 
    "на Чаки очень похож ))))",
    "красава братан",
    "Ты не бабник, нет - не льсти себе. ты - курицалюб",
    "пьяная рожа"
]
# Мова повідомлень, не обов'язковий параметр
source_lang='ru'
# Вибір моделі, що повинна використовуватись для задачі, 
# за замовчуванням 'DET_EMOTION_MODEL'
env_names = ['DET_EMOTION_MODEL', 'DET_TOPICS_MODEL', 'DET_APPROP_MODEL']
env = env_names[1]
#####################################
# r = requests.post(url+"/set_ip", json={'env': env, "ip":'http://172.19.0.2:8011'})
# Варіант 1: GET запити для кожного окремого повідомлення
for text in messages:
    r = requests.get(f'{url}/label?message={quote(text)}&source_lang={source_lang}&env={env}')
    translated_text = r.json()
    print(text,"\n=>RESPONSE:")
    pprint.pprint(translated_text, sort_dicts=False)
    print("\n")


# Варіант 2: POST запит який відсилає масив повідомлень
print("\nPost request that sends all sentences at once")
r = requests.post(url+"/label", json={'message': messages, "source_lang":source_lang, 'env': env})
response_data = r.json()
pprint.pprint(response_data, sort_dicts=False)

r = requests.post(f'{url}/set_model_env', json={'new_env':'DET_TOPICS_MODEL'})
response_data = r.json()
pprint.pprint(response_data, sort_dicts=False)
```

В результаті виконання було отримано, для GET запиту по одному повідомленню:

```
Я люблю дарить улыбку,  
=>RESPONSE:
{'text': ['Я люблю дарить улыбку, '],
 'source_lang': 'ru',
 'label': ['POSITIVE'],
 'logits': [[0.005161006469279528, 0.015147444792091846, 0.9796915650367737]],
 'calculation_time': 0.4088881015777588}


на Чаки очень похож )))) 
=>RESPONSE:
{'text': ['на Чаки очень похож ))))'],
 'source_lang': 'ru',
 'label': ['NEUTRAL'],
 'logits': [[0.02079816348850727, 0.5608097910881042, 0.41839200258255005]],
 'calculation_time': 0.40806150436401367}


красава братан 
=>RESPONSE:
{'text': ['красава братан'],
 'source_lang': 'ru',
 'label': ['POSITIVE'],
 'logits': [[0.007080805022269487, 0.006249494384974241, 0.9866697788238525]],
 'calculation_time': 0.39797306060791016}


Ты не бабник, нет - не льсти себе. ты - курицалюб 
=>RESPONSE:
{'text': ['Ты не бабник, нет - не льсти себе. ты - курицалюб'],
 'source_lang': 'ru',
 'label': ['NEUTRAL'],
 'logits': [[0.05387836694717407, 0.77876216173172, 0.1673593968153]],
 'calculation_time': 0.5120372772216797}


пьяная рожа 
=>RESPONSE:
{'text': ['пьяная рожа'],
 'source_lang': 'ru',
 'label': ['NEGATIVE'],
 'logits': [[0.9927225708961487, 0.005313348490744829, 0.0019640736281871796]],
 'calculation_time': 0.3383290767669678}
```

Для POST запиту з масивом повідомлень:

```
Post request that sends all sentences at once
{'text': ['Я люблю дарить улыбку, ',
          'на Чаки очень похож ))))',
          'красава братан',
          'Ты не бабник, нет - не льсти себе. ты - курицалюб',
          'пьяная рожа'],
 'source_lang': 'ru',
 'label': ['POSITIVE', 'NEUTRAL', 'POSITIVE', 'NEUTRAL', 'NEGATIVE'],
 'logits': [[0.005161001347005367, 0.015147430822253227, 0.9796915650367737],
            [0.020798159763216972, 0.5608097910881042, 0.4183920919895172],
            [0.007080798037350178, 0.006249497644603252, 0.9866697788238525],
            [0.05387839674949646, 0.7787622809410095, 0.16735929250717163],
            [0.9927225708961487, 0.005313343834131956, 0.0019640708342194557]],
 'calculation_time': 1.644493818283081}
```


Усі моделі монтуються в докер динамічно, для запобігання збільшення розміру контейнеру. Також усі кешовані файли зберігаються в папці `/cache/`, а отже за необхідності їх можна буде легко скопіювати з докеру у випадку аналізу виконання та інших задач.
